# 线段树
线段树是从普及组到noip都会考的算法，自从下文以后，线段树的难度陡然上升，省选可能都考了。  
[第9章](https://yutong.site/wp-content/uploads/2018/09/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2016%E8%AE%BA%E6%96%87%E9%9B%86.pdf)


### 线段树基本功能
线段树是一棵完全二叉树，每一个节点维护一个区间 $[l, r]$ ，节点左儿子维护 $[l, mid]$ ，右儿子维护 $[mid+1, r]$ 。每次修改的时候，从根一直向下走到叶子，然后回溯的时候进行维护。  
查询的时候，直接判断当前节点维护的区间是否包含于询问区间，是，则累计贡献；否则递归求解。一个长度为 $len$ 区间最坏会被分成一个 $\frac {len} 2$ 的区间直接回答和两个 $\frac {len} 4$ 的区间递归求解，即 $E(x) = 2E(\frac x 4) + 1$ ，时间复杂度为 $O(n \log_2 n)$ 。  
不难发现，线段树上真正保存节点的只有叶子节点，即空间使用率约 $50 \%$ 。当 $n$ 不为 $2^k$ 时，叶子最多有 $2n$ 个，即线段树的空间要开 $4n$    
能被线段树正常维护的信息必须具有区间可加性，即满足 $f(l,r) = f(l,x) \oplus f(x+1,r) $ ， 其中 $x \in (l, r)$ ，$\oplus$ 代表一种二元操作。  
这一阶段的线段树一般作为一种工具使用（如扫描线），较少直接考察。

##### 动态开点
当需要维护的区间十分稀疏的时候，不需要全部节点都建出来，只需要对有值的地方建树即可。

##### 权值线段树
将值域转化为线段树的下标，可以作为一种弱化板的平衡树使用。

##### 线段树优化动态规划
当动态规划的阶段划分清晰的时候，可以使用线段树直接维护所有的状态，然后全局转移，时间复杂度可以低于枚举所有状态的复杂度。


### 懒标记
线段树还可以支持区间修改。具体地，在每一个节点处维护一个懒标记代表对区间的整体操作，然后需要从这个节点递归的时候将懒标记下传。只要保证每次访问到的节点维护的信息是正确的就行了。修改一个区间最多访问到 $n\log_2n$ 个节点，证明同上。  

##### 生命周期 & 操作序列
懒标记能高效率维护区间操作，实质上是将对一连串针对同一个区间的操作合并起来。为了方便研究，我们加入时间轴，代表修改操作的执行次序，这个执行次序称为**操作序列**。  
一个线段树节点 $k$ 的**生命周期**定义为从两次调用 ```pushdown(k)``` 的间隔。结合两个定义，一个节点的懒标记本质上维护了其生命周期内的操作序列；而```pushdown```的作用是结束该节点的生命周期，将其维护的操作序列接到儿子节点操作序列的末尾。一个节点的生命周期一定在其儿子节点生命周期开始之后开始，在其儿子节点生命周期结束之前结束，即父亲一定比儿子更为频繁地调用 ```pushdown```。

##### 历史最值模型
有了上述的定义，可以研究一个问题；
> [**P3414 CPU监控**](https://www.luogu.com.cn/problem/P4314)   
> 维护一个数列，支持以下操作：  
> + Q $l,r$ : 查询 $[l,r]$ 区间内的最大值；
> + A $l,r$ : 查询 $[l,r]$ 中的历史最大值；
> + P $l,r,v$ : 将 $[l,r]$ 中的数加上 $v$；
> + C $l,r,v$ : 将 $[l,r]$ 中的数改为 $v$；  

观察到一个节点被掉用过C操作以后的P操作都可以视为C操作，于是可以记录一下几个懒标记：  
`maxn, hmax` : 当前最大值和历史最大值；  
`add, mxadd` : 当前加法标记和生命周期内加法标记的最大值；  
`mdf, mxmdf` : 当前修改标记和生命周期内修改标记的最大值；  
`pre, bmdf`  : 生命周期开始时的 `maxn` 和生命周期中的操作序列内是否有C操作。  

每次 `update_add` 的时候，判断是否已经执行过C操作；每次 `update_mdf` 的时候，搭上 `bmdf` 标记:
```cpp
void inline update_hix(segtree_node &a) {
	a.hmax = max(a.hmax, a.pre + a.mxadd);
	if(a.mdfed) a.hmax = max(a.hmax, a.mxmdf);
}
void inline update_add(segtree_node &a, int val, int mxval) {
	a.maxn += val;
	if(a.mdfed) a.mxmdf = max(a.mxmdf, a.mdf + mxval), a.mdf += val;
	else a.mxadd = max(a.mxadd, a.add + mxval), a.add += val;
	update_hix(a);
}
void inline update_mdf(segtree_node &a, int val, int mxval) {
	a.mdfed = true; a.maxn = val;
	a.mxmdf = max(a.mxmdf, mxval); a.mdf = val;
	update_hix(a);
}
```


### 势能线段树

##### 每个元素有限次操作
考虑实现支持以下操作的线段树：
>+ 修改： $a_i'=\lfloor \sqrt a_i \rfloor$，其中 $i\in [l,r]$  
>+ 询问：求 $\sum_{i=l}^r a_i$  

不难发现，一个数最多被操作 $\log_2$ 次以后就会变成 $1$, 此后无论如何操作都会不再影响。因此，我们可以对于每一个区间维护一个最大值，当区间最大值为 $1$ 的时候，就不再往下递归。每一个元素最多被操作 $\log_2$ 次，每次操作最多访问 $\log_2$ 个节点，因此时间复杂度为 $O(n \log_2^2 n)$。

##### max-sec 势能
再次考虑实现支持以下操作的线段树：
> + 修改：$a_i' = a_i + x$， 其中 $i \in [l,r]$
> + 修改：$a_i' = \min(a_i, x)$，其中 $i\in [l,r]$
> + 询问：$\sum_{i=l}^r a_i$
> + 询问：$\max_{i=l}^r \{a_i\}$

一种比较直接的做法是每一个节点记录一个 ```max``` ，操作2 当 $\max < x$ 的时候直接返回。然而，这样做的复杂度是错的，因为还存在操作1。

正确的做法的是每一个节点不仅要维护 ```max``` ，还要维护 ```sec``` 和 ```maxcnt``` ，代表区间内不和 $\max$ 相同的次大值。对于操作1, 直接加上就行；对于操作2，分情况讨论：  
> 1#   $x \in (-\infty, sec]$   直接暴力递归求解  
> 2#  $x\in (sec, max)$   利用 ```maxcnt``` 和 ```max``` 标记维护出 ```sum```，然后修改 ```max```，**不向下递归**  
> 3#  $x\in [max, +\infty)$  不做任何事情  

可以证明，这样做的时间复杂度是 $O(n \log_2^2 n)$ ：
> 定义势能函数 $E(x)$ 表示现在线段树中有几个元素不相同， 初始最多为 $n$ ：  
> + 对于 1 操作，$E(x)$ 不改变，最多访问 $\log_2n$ 个节点 （证明见上）
> + 对于 2 操作，查询到整块时若为 2# 或 3#， $E(k)$ 不改变，最多访问 $\log_2 n$ 个节点 （证明同上）；若为 1# ，则 $E(x)$ 至少减少 $1$, 因为至少有两个数被改成同一个值，因此 1# 操作最多被执行 $n$ 次。  
> + 因此，在维护的过程中，整棵线段树的势能在不断地降低，总的时间复杂度为 $O(n\log_2 n + n \log_2 n) = O(n \log_2 n)$ 。

因此，结合上一节中历史最值的维护，可以切掉这题：
[【模板】线段树 3](https://www.luogu.com.cn/problem/P6242)
[code](https://www.luogu.com.cn/record/list?pid=P6242&user=235868)
