# 线段树

## 正常的线段树

### 线段树基本构成（单点修改）

线段树是一棵完全二叉树，每一个节点维护一个区间 $[l, r]$ ，节点左儿子维护 $[l, mid]$ ，右儿子维护 $[mid+1, r]$ 。每次修改的时候，从根一直向下走到叶子，然后回溯的时候进行维护。

查询的时候，直接判断当前节点维护的区间是否包含于询问区间，是，则累计贡献；否则递归求解。一个长度为 $len$ 区间最坏会被分成一个 $\frac {len} 2$ 的区间直接回答和两个 $\frac {len} 4$ 的区间递归求解，即 $E(x) = 2E(\frac x 4) + 1$ ，时间复杂度为 $O(n \log_2 n)$ 。

不难发现，线段树上真正保存节点的只有叶子节点，即空间使用率约 $50 \%$ 。当 $n$ 不为 $2^k$ 时，叶子最多有 $2n$ 个，即线段树的空间要开 $4n$   

能被线段树正常维护的信息必须具有区间可加性，即满足 $f(l,r) = f(l,x) \oplus f(x+1,r) $ ， 其中 $x \in (l, r)$ ，$\oplus$ 代表一种二元操作。

这一阶段的线段树一般作为一种工具使用（如扫描线），较少直接考察。

[【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

### 懒标记

线段树还可以支持区间修改。具体地，在每一个节点处维护一个懒标记代表对区间的整体操作，然后需要从这个节点递归的时候将懒标记下传。只要保证每次访问到的节点维护的信息是正确的就行了。修改一个区间最多访问到 $n\log_2n$ 个节点，证明同上。

有多个信息维护的时候，要注意懒标记下传的顺序。

[【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)

### 动态开点线段树

当需要维护的区间十分稀疏的时候，不需要全部节点都建出来，只需要对有值的地方建树即可。

### 权值线段树

将值域转化为线段树的下标，可以作为一种弱化板的平衡树使用。

### 线段树优化动态规划

当动态规划的阶段划分清晰的时候，可以使用线段树直接维护所有的状态，然后全局转移，时间复杂度可以低于枚举所有状态的复杂度。

## 可持续化线段树

### 主席树

观察线段树单点修改时的结构变化，发现每次修改只会影响一条从根到叶子的链。于是每次修改的时候新建一条链的点，左右儿子直接引用原节点。支持历史版本。

可持久化线段树的历史版本可以当作是时间，也可以看成下标，如查找区间第 $k$ 大。

可持久化线段树可以与树的深度优先遍历结合。每一个节点使用一个历史版本维护其到根路径的信息，回溯的时候直接返回历史版本。

[【模板】可持久化线段树 1（可持久化数组）](https://www.luogu.com.cn/problem/P3919) [【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)

### 带修主席树  **[todo]**

普通的主席树是不支持修改某一个历史版本的，~~因为修改历史会影响现在~~。当我们修改第 $i$ 个历史版本，第 $[i, n]$ 个历史版本均会改变。但是，我们可以使用树状数组来维护历史版本，因为每次修改只会影响后缀。

时间复杂度 $O(n \log_2^2 n)$

### 主席树区间修改 **[todo]**

普通的主席树不能支持区间修改是因为  ```pushdown``` 操作会影响左右儿子。但是，我们可以将懒标记永久化。每次递归到节点的时候不再下传标记，取而代之的是在回溯的时候再把贡献累加。

## 势能线段树

### 每个元素有限次操作

考虑实现支持以下操作的线段树：

>1. 修改： $a_i'=\lfloor \sqrt a_i \rfloor$，其中 $i\in [l,r]$
>2. 询问：求 $\sum_{i=l}^r a_i$ 

不难发现，一个数最多被操作 $\log_2$ 次以后就会变成 $1$, 此后无论如何操作都会不再影响。因此，我们可以对于每一个区间维护一个最大值，当区间最大值为 $1$ 的时候，就不再往下递归。每一个元素最多被操作 $\log_2$ 次，每次操作最多访问 $\log_2$ 个节点，因此时间复杂度为 $O(n \log_2^2 n)$。

### max-sec 势能 [todo]

再次考虑实现支持以下操作的线段树：

> 1. 修改：$a_i' = a_i + x$， 其中 $i \in [l,r]$
> 2. 修改：$a_i' = \min(a_i, x)$，其中 $i\in [l,r]$
> 3. 询问：$\sum_{i=l}^r a_i$ 
> 4. 询问：$\max_{i=l}^r \{a_i\}$

一种比较直接的做法是每一个节点记录一个 ```max``` ，操作2 当 $\max < x$ 的时候直接返回。然而，这样做的复杂度是错的，因为还存在操作1。

正确的做法的是每一个节点不仅要维护 ```max``` ，还要维护 ```sec``` 和 ```maxcnt``` ，代表区间内不和 $\max$ 相同的次大值。对于操作1, 直接加上就行；对于操作2，分情况讨论：

> 1#   $x \in (-\infty, sec]$   直接暴力递归求解
>
> 2#  $x\in (sec, max)$   利用 ```maxcnt``` 和 ```max``` 标记维护出 ```sum```，然后修改 ```max```，**不向下递归**
>
> 3#  $x\in [max, +\infty)$  不做任何事情

可以证明，这样做的时间复杂度是 $O(n \log_2^2 n)$ 。具体证明如下：

> 定义势能函数 $E(x)$ 表示现在线段树中有几个元素不相同， 初始最多为 $n$ ：
>
> 1. 对于 1 操作，$E(x)$ 不改变，最多访问 $\log_2n$ 个节点 （证明见上）
> 2. 对于 2 操作，查询到整块时若为 2# 或 3#， $E(k)$ 不改变，最多访问 $\log_2 n$ 个节点 （证明同上）；若为 1# ，则 $E(x)$ 至少减少 $1$, 因为至少有两个数被改成同一个值，因此 1# 操作最多被执行 $n$ 次。
>
> 因此，在维护的过程中，整棵线段树的势能在不断地降低，总的时间复杂度为 $O(n\log_2 n + n \log_2 n) = O(n \log_2 n)$ 。

### 设计 $E(x)$ 函数 [todo]

$E(x)$ 函数是势能线段树的核心。一般设计 $E(x)$ 函数需要保证任何操作都不会提升 $E(x)$ （或者只提升少量势能），暴力操作至少要使 $E(x)$ 降低 $1$ 以上。$E(x)$ 函数的设计具有极大技巧性。

[P6242 【模板】线段树 3](https://www.luogu.com.cn/problem/P6242)

## 线段树合并 & 分裂

### 线段树合并

线段树是支持合并的（暴力合并），每次合并的时间复杂度为 $O(n \log_2 n)$ 。但是，若是保证每一个元素至多被合并一次，那么线段树合并全过程的时间复杂度为 $O(n \log_2 n)$，因为合并的时候至多为每一个元素递归 $O(\log_2n)$ 个节点。

线段树合并的模型一般用于树上。当 $u$ 节点搜完 $v$ 后，将以 $v$ 为根的线段树合并到以 $u$ 为根的线段树中，同时不再使用以 $v$ 为根的线段树。可以用来优化树形动态规划等树上模型。

[[Vani有约会\]雨天的尾巴 /【模板】线段树合并](https://www.luogu.com.cn/problem/P4556)

### 线段树分裂

有一个看似是 Splay 的模型：

> 维护 $n$ 个可重集，实现以下功能：
>
> 1. 将可重集 $p$ 中值域为 $[l,r]$ 之间的元素分离到可重集 $q$ 中
> 2. 将可重集 $p$ 合并到 $q$ 中
> 3. 查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。
> 4. 查询可重集 $p$ 中排名为 $k$ 的元素

辛苦写完 5kb 的 Splay 代码后，发现时间复杂度是错的，因为 Splay 赖以保持时间复杂度的势能函数$E(x) = \sum_i \operatorname {dep}_i$ 在合并的时候二次增加 。

真正的解法应该是全值线段树分裂后再合并。线段树分裂时只需要访问 $[l,r]$ 区间的节点，时间复杂度是 $O(\log_2n)$ 的。

但是真正线段树合并的时间复杂度是不确定的。具体时间复杂度的证明不清晰，评判时间复杂度正确性依靠倒数第二个数据。

[P5494 【模板】线段树分裂](https://www.luogu.com.cn/problem/P5494)


