# 计算几何

建系 + 向量 = 15分钟一道IMO几何题                                           ----- wxl, ~~IMO AKER~~                                                                                                       

哦xes兴趣的向量题原来这么简单，看来退班是个明确的决定。  ----- cxw,  ~~IMO AKER * 2~~

#0x0 前置知(mu) 识(ban)

### 0x01 向量（点）

在 OI 上向量用有序点对 $(x, y)$ 表示， 一般使用结构体储存，基本操作同数学上的定义一样。

***注** 向量叉积其实是三维向量，但我们只需用到它的膜长

```cpp
struct vect{
	double x, y;
	vect(double _x = 0.0, double _y = 0.0) { x = _x, y = _y; }
	vect operator+ (vect A) { return vect{ x + A.x, y + A.y }; }
	vect operator- (vect A) { return vect{ x - A.x, y - A.y }; }
	vect operator* (double k) { return vect{ x * k, y * k }; }
	vect operator/ (double k) { return vect{ x / k, y / k }; }
	double operator* (vect A) { return x * A.x + y * A.y; }
	double operator/ (vect A) { return x * A.y - y * A.x; }
	vect rotate(double theta) { return vect{ x * cos(theta) - y * sin(theta), \
											 x * sin(theta) + y * cos(theta)}; }
	bool operator== (vect A) { return x == A.x && y == A.y; }
};
typedef vect point;
```

### 0x02 直线

直线储存一个点和一个向量，表示位置和方向。

求直线交点比较阴间，要使用正弦定理~~（没图先咕咕了）~~

``` cpp
struct line{
	point p; vect v; int ord;
	point cross(line A){ 
		vect u = p - A.p;
		double t = (A.v / u) / (v / A.v);
		return p + v * t;
	}
};
```

### 0x03 多边形

按顺序储存每一个顶点即可，一般从最左下角开始。

~~没有模板~~

## 0x1 平面凸包

### 0x10 [P1452【模板】旋转卡壳 ](https://www.luogu.com.cn/problem/P1452)

这个算法比较常见，经常会被其他多边形算法套着出题。~~（调多边形算法1h然后发现多边形求错了）~~

平面凸包运用了多边形斜率的单调性。先确定左下角的点，然后按照与左下角点的斜率排序，再依次放入单调队列中，若发现斜率减小就出队。

时间复杂度 $O(n log_2 n)$, 瓶颈在排序。

()[*flag1*] 这个东西经常被套起来使用，板子最好能处理共线和重点的情况，使求的的多边形标准化，为后面其他多边形铺垫。

### 0x12 [P3829 [SHOI2012]信用卡凸包](https://www.luogu.com.cn/problem/P3829)

这一题跟板子差不多，容易发现圆环总能拼成一个整圆，然后用每个角的圆心跑凸包就好了。

注意旋转中心是矩形的中心，因此先进行向量旋转再加上中心向量；然后输入的 $a$ , $b$ 是**反过来**的！

*拓展：若圆角的半径不一样，还能做么?* 

### 0x13 [P3299 [SDOI2013]保护出题人](https://www.luogu.com.cn/problem/P3299)

其实，斜率优化dp**（截距最大）**的单调栈中维护的就是一个凸包。然而，平面凸包还可以维护**斜率最大**：

> 在点集 $S$ 中找到两点，使得它们连线的斜率最大。即求：
> $$
> max\{ \dfrac {y_i-y_j} {x_i-x_j} \mid i, j \in S\}
> $$

可以按 $x$ 排序后依次枚举 $i \in S$ ，求出 $i, j \mid (x_j < x_i)$ 连线斜率的最大值。可以想象过 $i$ 的直线 $l$ 在旋转，第一个碰到的就是当前的最大值。

容易发现， $l$ 在旋转的过程中只会碰到下凸壳 $T$ 上的点。即 $T$ 满足 $\forall i ,j, k \in T, 只要 x_i < x_j, 恒有 \dfrac{y_i - y_k}{x_i - x_k} < \dfrac{y_k - y_j}{x_k - x_j} $。

设当前的点为 $p$ 。与斜率优化dp类似，可以用单调队列维护 $T$ 。但是，每次更新答案的时候不能直接取队头，要二分出点 $k \in T$ ,  $\dfrac{y_k - y_{k-1}}{x_k - x_{k-1}} < \dfrac{y_k - y_p}{x_k - x_p} < \dfrac{y_k - y_{k+1}}{x_k - x_{k+1}}$。时间复杂度 $O(n\ log_2 n)$.

### 0x14 [P2924 [USACO08DEC]Largest Fence G](https://www.luogu.com.cn/problem/P2924)

这题的关键在于如何将 $O(n^4)$ 的 dp 优化到 $O(n^3)$ 

暴力做法 ( 即 $O(n^4)$ 的解法 ) 中做了 $n$ 次 dp , 每次 dp 要记住当前到了 $i$ 个点, 前驱是 $j$ 点，一共有 $O(n^2)$ 个状态，转移时又要 $O(n)$ 转移，总复杂度 $O(n^4)$. 

考虑发现 ~~(看题解发现)~~， 第一层循环 (即枚举第一个在目标凸包上的点) 很难优化掉，但是 dp 的状态有较多冗余。于是从边考虑，将所有的边存起来，按照极角升序排序，做 dp 的时候枚举排序后的边 $(u, v)$, 有 $f_v = max \{ \ f_v, \ f_u + 1 \ \}$ .

dp 正确性的证明与背包问题的证明有异曲同工之妙。事实上，第一层循环枚举的是目标凸包上**最靠上 ( $y$ 最大 ) 的点**，于是凸包上的边的极角**依次上升**。又由于我们按照极角从小到大的顺序进行 dp， 我们实质上是以边为阶段（阶段有序），以点为决策进行 dp，保证了每次转移的顺序其实就是所表示凸包上点的顺序。

时间复杂度瓶颈在排序: $O(n\ log_2 n)$

## 0x2 旋转卡壳

~~这东西真让人脑袋卡壳~~

[**0x20【模板】旋转卡壳**](https://www.luogu.com.cn/problem/P1452) 

**旋转卡(ka)壳(qiao)** 用于求解多边形中距离最远的点。具体实现起来就是  ~~暴力 $O(n^2)$ 枚举~~  枚举多边形上的每一条边，然后暴力找到离这条线段最远（三角形面积最大，即叉积最大）的顶点 $P$ 。然后发现逆时针有序枚举多边形的边的时候 $P$ 也在逆时针转，因此时间复杂度可以平摊下来变成 $O(n)$ 。

但是这个算法出题是一般会要求先做一遍平面凸包，导致对算法的健壮性要求较高。做平面凸包时要及时将**三点共线**和**重复点**排除掉。

[**0x21 P3187 [HNOI2007]最小矩形覆盖**](https://www.luogu.com.cn/problem/P3187)

[**0x22 UVA10173 Smallest Bounding Rectangle**](https://www.luogu.com.cn/problem/UVA10173)

(upd 2021.7.23)双倍经验（还是个黑的）

难点主要在判断左右点。判断的时候依据左右点在边上的投影最长，故使用点乘来判断。

然后因为左右点的判定过于相似，要保证左右点在最高点两侧，则要使用一个玄学代码:

```cpp
if(i == 1) r = t;
```

## 0x3 半平面交

[ **0x30 [CQOI2006]凸多边形 /【模板】半平面交** ](https://www.luogu.com.cn/problem/P4196)

半平面交是求解多个一次不等式的交集，但是在OI中主要用于生成凸多边形，凸多边形本身就是一个半平面交，可以与其他多边形算法结合。

半平面交求解算法主流是2006年的S&I算法：

1. 直线转成向量后按极角排序
2. 依次插入双段队列
3. 最后再将第一个向量重新插入，求出首尾交点

代码中的KEYS:

1. 直线向量 与 从直线基准点指向待检测点（队首尾交点） 判断位置关系 就是 判断 交点在直线哪一侧
2. 处理平行线
3. 将第一个向量再次加入队列是为了将队尾的一些无用向量去除，并且此时不需要考虑队首出队
4. THE F**KING $S = \dfrac{1}{2} \vec{a} \times  \vec{b}$  , 原式要乘 $\dfrac 1 2$

[**P3256 [JLOI2013]赛车**](https://www.luogu.com.cn/problem/P3256)

基本上是板子，注意要围上 $y$ 轴 ( 保证 $t > 0$  )，然后要注意两辆车完全一样的坑点

[**P2600 [ZJOI2008]瞭望塔**](https://www.luogu.com.cn/problem/P2600)

思路比较简单，就是按轮廓（称为下多边形）跑一遍半平面交，得到能建造瞭望塔的范围，称为上多边形。由于多边形的边是直线，所以最值一定不会在边的中间取到，因此对于上下两个多边形每个顶点的 $x$ 轴统计一次答案就好。

然而。。。。。。

1. ```eps``` 不能只开 ```1e5``` ( 1h )
2. 题面出锅了，$10^6$ 写成了 $106$ 。 但是```inf```只开 $1e6$ 依然死，因为直线可以交在很高的地方。。。[link](https://www.luogu.com.cn/blog/105254/solution-p2600) (2h)
3. 这里上凸多边形可能是不存在的，要在__极远__的地方围上一个大正方形。 (0.5h)

巨坑好题。

