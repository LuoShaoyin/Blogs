# 生成函数讲义

*吕欣*，2021 年 12 月 16 日.

## 生成函数简介

### 一般生成函数

假设我们有一个数列 $(f_i)_{i\ge 0}$，其中 $f_i$ 表示规模为 $i$ 的特定组合对象的个数（e.g., $i$ 个点的二叉树个数；长度为 $i$ 的 $01$ 序列个数等）。那么我们可以定义 $(f_i)_i$ 的一般型生成函数为
$$
F(x) = \sum_{i=0}^{\infty} f_i x^i.
$$
在之后的讨论中，我们可以把所有满足 $F(x)$ 的要求的组合对象简记为 $f$-对象（这也就是说，共有 $f_i$ 个规模为 $i$ 的 $f$-对象）。

如果我们有两个生成函数 $F(x), G(x)$，我们可以定义他们之间的加法和乘法运算：
$$
F(x)+G(x) = \sum_{i\ge 0} (f_i+g_i) x^i, \\
F(x)\cdot G(x) = \sum_{i\ge 0}\left( \sum_{j=0}^i f_j g_{i-j} \right) x^i.
$$
这两种运算有着非常直观的组合解释：$F+G$ 表示我们关心的组合对象被分为了两类 (f 和 g），规模为 $i$ 的 $f$ 类组合对象有 $f_i$ 个，$g$ 类有 $g_i$ 个，那么我们关心的组合对象的个数就有 $f_i+g_i$ 个。$F\cdot G$ 表示我们关心的组合对象是由一个 $f$-对象 $A$ 和一个 $g$-对象 $B$ 组成的 pair，并且一个 pair $(A,B)$ 的规模为 $|A|+|B|$。那么 $F\cdot G$ 可以计算规模为 $i$ 的 pair 个数。

**生成序列.** 推广一下，我们考虑 $F(x)^k$，这表示我们关心的组合对象是由 $k$ 个 $f$-对象构成的一个序列，并且这个序列的规模是构成序列的每个元素的规模之和。在此情形下 $F(x)^k$ 给出了我们关心的组合对象的生成函数。我们可以对 $k$ 求和，得到
$$
\sum_{k=0}^{\infty} F(x)^k= \frac{1}{1-F(x)}.
$$
那么可以看出，$\frac{1}{1-F(x)}$ 就是 “由 0 个或多个 $f$-对象构成的有序序列” 的生成函数。需要注意的是，这里我们假设 $f_0 =0$，也即没有规模为 $0$ 的 $f$-对象（否则，生成的序列里可以有任意多个规模为 0 的 $f$-对象，上式不良定义）。

**生成集合.** 在有的场合里，我们也关心 “由 0 个或多个 $f$-对象构成的**多重集**” 的生成函数，这里一个集合的规模定义为集合中元素规模之和。与之前一样，我们假设 $f_0 = 0$，否则集合里可以包含任意多个规模为 0 的 $f$-对象，此问题不良定义。

首先反驳一个错误的想法。有人可能会说，$\frac{F(x)^k}{k!}$ 就是包含 $k$ 个 $f$-对象的多重集的生成函数，对 $k$ 求和就得到了 $e^{F(x)}$。事实上，如果一个方案包括了 $k$ 个两两不同的 $f$-对象，那么这个方案在 $F(x)^k$ 中确实被算了 $k!$ 遍，做除法即可。但是如果一个方案中某个$f$-对象出现了多次，它在$F(x)^k$中会被算少于 $k!$ 遍，简单地除以 $k!$ 会让结果变小。

现在叙述正确的做法。考虑对于**每个** $f$-对象，枚举它在最后生成的多重集里出现了多少次。对于一个规模为 $i$ 的 $f$-对象，它可以在最终的集合里出现 0 次或者多次，所对应的生成函数即为
$$
1 + x^i + x^{2i} + \dots  = \frac{1}{1-x^i}.
$$
因为总共有 $f_i$ 个不同的规模为 $i$ 的 $f$-对象，要对它们依次做决策，所对应的生成函数即为
$$
\left( \frac{1}{1-x^i} \right)^{f_i}.
$$
最后，枚举 $i$ 并求乘积，我们所求的生成函数即为
$$
G(x) = \prod_{i=1}^{\infty} \left( \frac{1}{1-x^i} \right)^{f_i}.
$$
我们使用 ln-then-exp 技巧做一些处理，得到一个更清晰的式子：
$$
\begin{aligned}
G(x)
&=\exp\left(-\sum_{i=1}^{\infty} f_i \ln (1-x^i) \right) \\
&=\exp \left(\sum_{i=1}^{\infty}f_i \cdot \sum_{j=1}^{\infty} \frac{x^{ij}}{j}\right) \\
&= \exp \left( \sum_{j=1}^{\infty}\frac{1}{j} \sum_{i=1}^{\infty} f_i \cdot x^{ji}\right) \\
&= \exp\left( \sum_{j=1}^{\infty} \frac{F(x^j)}{j}\right).
\end{aligned}
$$
相比之前错误想法得到的结果 $\exp(F(x))$，这里的正确结果添加了形如 $F(x^j)/j$ 的一系列修正项。

*注.* 另有一个[基于 Polya 原理的推导方法](https://atcoder.jp/contests/abc230/editorial/3027)，可以得出一样的结论。

*注.* 在网络上有些资料中把 $F\to \exp\left( \sum_{j=1}^{\infty} F(x^j)/j\right)$ 这一操作称为 Euler 变换，我尚未找到此命名的原始出处。

> 例. 计算有 $N$ 个节点的**无标号**有根树个数，这里 $N\le 2\times 10^5$。

> 解法. 设所求数列的生成函数为 $F(x)$。考虑生成一个有根树的过程：
>
> * 首先固定一个根节点。
> * 根节点连出若干个子树，子树之间不区分顺序（相当于多重集）。
>
> 由此容易看出，$F$ 满足递归式
> $$
> F(x) = x\cdot \exp\left( \sum_{j=1}^{\infty} \frac{F(x^j)}{j} \right).
> $$
> 可以使用分治FFT（在网络上有人称为“半在线卷积”）解决上述问题。计算量为 $O(N\log^2 N)$。

也可以参考[这个题目](https://atcoder.jp/contests/abc230/tasks/abc230_h).

### 指数生成函数

有时候我们考虑的计数问题涉及到 $n$ 个不同的元素之间可能的结构关系（例如 $n$ 个点的带标号无向连通图个数、$n$ 个元素构成的某种排列个数等）。指数生成函数是处理此类问题的利器。

一般地，假设我们有一个数列 $(f_i)_{i\ge 0}$，其中 $f_i$ 表示在 $i$ 个互相可以区分的元素之间可以建立的不同的结构数（e.g., $i$ 个点带标号无向连通图个数，$i$ 个元素的错位排列个数），那么我们定义 $(f_i)_i$ 的指数型生成函数为
$$
F(x) = \sum_{i=0}^{\infty} f_i \frac{x^i}{i!}.
$$
与一般生成函数相比，此处我们的形式幂级数的“核函数”变成了 $\frac{x^i}{i!}$ 而不是 $x^i$。我们可以把所有满足 $F(x)$ 的要求的结构记为 $f$-结构（也就是说，在 $i$ 个不同的元素之间，可以建立 $f_i$ 种不同的 $f$-结构）。

如果有两个指数型生成函数 $F(x), G(x)$，我们可以定义他们之间的加法和乘法运算：
$$
F(x)+G(x) = \sum_{i\ge 0} (f_i+g_i) \frac{x^i}{i!}, \\
F(x)\cdot G(x) = \sum_{i\ge 0}\left( \sum_{j=0}^i \binom{n}{j} f_j g_{i-j} \right) \frac{x^i}{i!}.
$$
这两种运算同样有着非常直观的组合解释：$F+G$ 表示我们可以在 $i$ 个元素之间建立 $f$-结构或者 $g$-结构，因为存在 $f_i$ 个 $f$-结构和 $g_i$ 个 $g$-结构，因此存在 $f_i+g_i$ 个我们关心的结构。$F\cdot G$ 则是计算了把 $n$ 个元素*划分*成两组，然后在两组中分别建立一个 $f$-结构和一个 $g$-结构的方案数。

**生成序列.** 推广一下，我们考虑 $F(x)^k$，它表示把 $n$ 个元素划分成*带标号*（有序）的 $k$ 组，并且在每组中建立一个 $f$-结构的方案数。对 $k$ 求和就得到 $\frac{1}{1-F(x)}$. 它表示这样的结构数：把 $n$ 个元素划分成**有序**的若干组，并在每一组之中建立一个 $f$-结构。

**生成集合.** 有时我们只关心把元素划分成 $k$ 组，但是这 $k$ 组并不需要区分顺序。此时我们可以考虑 $\frac{F(x)}{k!}$，它表示把 $n$ 个元素划分成 $k$ 组，并且在每组里建立一个 $f$-结构的方案数。当 $f_0 = 0$ (也即不存在建立在空集上的结构）的时候，$\frac{F(x)}{k!}$ 的计数一定是不重不漏的（这是因为 $n$ 个元素互相可以区分，无论它们被怎样划分成 $k$ 组，同一个划分方案总是会在 $F(x)^k$ 中计入 $k!$ 遍）。我们对 $k=0,1,\dots,\infty$ 求和，就得到
$$
G(x) = \sum_{k=0}^{\infty} \frac{F(x)^k}{k!} = \exp(F(x)).
$$
此时，$G(x)$ 表示这样一个生成函数：我们有 $n$ 个不同的元素，把它们划分成若干组，并且在每组之中建立一个 $f$-结构的方案数。

> 例. 令 $H(x)=\sum_n h_n \cdot x^n/n!$ 表示 $n$ 个点的带标号无向图的指数生成函数，熟知 $h_n = 2^{\binom{n}{2}}$。令 $F(x)=\sum_{n} f_n\cdot x^n/n!$ 表示 $n$ 个点的带标号连通无向图的指数生成函数。因为每个无向图都可以唯一地划分为若干个连通块，我们得到 $H(x) = \exp(F(x))$，也就是 $F(x) = \ln H(x)$。通过多项式求 ln，可以在 $O(n\log n)$ 时间内计算出 $F(x)$ 的前 $n$ 项系数。

### 生成函数和递推

处理形如 $P(x) / Q(x)$，$\deg P < \deg Q$ 的形式幂级数的一种常用方法是递推。我们令 $A(x) = \frac{P(x)}{Q(x)}$，那么就有 $A(x)Q(x) = P(x)$，设 $Q(x) = 1 + \sum_{i=1}^{\deg Q} q_i x^i$， $P(x)= \sum_{i=0}^{\deg P} p_i x^i$，考虑第 $n$ 项公式的系数，当 $n > \deg P$ 时候就有
$$
a_n = - \sum_{i=1}^{\deg Q}q_i\cdot  a_{n-i}.
$$
注意到这是一个线性递推的形式。当 $n \le \deg P$ 时候，有
$$
a_n = p_n - \sum_{i=1}^{n} q_i \cdot a_{n-i}.
$$
不难发现通过选择合适的 $(p_i)_{0\le i\le \deg P}$，我们可以取到任意的初值 $(a_i:0< i < \deg Q)$.

$A(x)Q(x) = P(x)$ 只能实现线性递推。如果我们有一个微分方程 $A(x)Q_0(x)+ A'(x)Q_1(x) +\dots + A^{(t)}(x)Q_t(x) = P(x)$，那么我们就能构造一个包含指标 $n$ 的递推（这种递推被称为整式递推）。卡特兰数的 $O(1)$ 时间递推公式就是这个技巧的一个经典应用。

### 常见的几个生成函数形式

有必要熟练掌握以下形式幂级数的闭形式。

1. $\sum_{i=0}^{\infty}x^i = \frac{1}{1-x}$.
2. $\sum_{i=0}^{\infty} \binom{n+k-1}{k-1} x^i = \frac{1}{(1-x)^k}$.
3. $\sum_{i=1}^{\infty} \frac{x^i}{i} = -\ln(1-x)$.
4. $\sum_{i=1}^{\infty} \frac{x^i}{i!} = \exp(x)$.
5. $\sum_{i=0}^{\infty} x^{2i} = \frac{1}{1-x^2}$, $\sum_{i=0}^{\infty} \frac{x^{2i}}{(2i)!} = \frac{e^x+e^{-x}}{2}$.
6. （五边形数定理） $\prod_{n=1}^{\infty}(1-x^n) = \sum_{n=-\infty}^{\infty} (-1)^n x^{\frac{n(3n+1)}{2}}$.

## 卡特兰数

**基于递归式的定义**：$h_0 = 1$, $h_n = \sum_{i=0}^{n-1} h_i h_{n-i-1}, \forall n\ge 1$.

**通项公式的定义**：$h_n = \binom{2n}{n}-\binom{2n}{n+1} = \frac{1}{n+1}\binom{2n}{n}$.

**卡特兰数的生成函数**：$zC(z)^2 + 1 = C(z), C(0) = 1$ 的解.

### 卡特兰数的几种组合意义

* $n+2$ 边形的不同的三角剖分方案数：固定一个多边形的一个边，考虑这个边所在的三角形的顶点，把问题划分成两个子问题。
* $n$ 个元素按照顺序入栈，可能的出栈顺序数：第一个进栈的元素是第 $i$ 个出栈，划分成 $i-1$ 和 $n-i$ 两个子问题。
* $n$ 个 `(` 和 $n$ 个 `)` 的合法括号序列个数：枚举和第一个左括号匹配的右括号的位置，划分成两个子问题。
* $n$ 个节点的无标号二叉树形态数：枚举左右子树的大小，划分成两个规模更小的子问题。
* 构造一个由 +1 和 -1 构成的长度为 $2n$ 的序列，满足序列和为 0，且任意的前缀和非负。
* 一个 $n\times n$ 的网格，从 $(0,0)$ 移动到 $(n,n)$，要求：第一步向右走且不穿越对角线的方案数。

### 组合推导

考虑第 5 个组合意义. 首先，任意构造一个和为 $0$ 的 $\pm 1$ 序列的方案数为 $\binom{2n}{n}$，但是这样会算进去一些不合法的方案。对于任意一种不合法的方案 $P = (a_1,\dots, a_{2n})$，考虑第一个 $i$ 使得 $\sum_{j=1}^{i}a_j = -1$，把 $a_1\dots a_i$ 翻转符号，它对应了一个和为 $2$ 的序列。可以证明“总和为 0 但是不合法的方案” 和 “总和为 2 的方案” 之间存在一个双射，因此我们知道不合法的方案总数为 $\binom{2n}{n-1}$。因此所求方案数为 $\binom{2n}{n} - \binom{2n}{n+1}$。

### 生成函数

令 $C(z) = \sum_{i=0}^{\infty} h_i z^i$ 为卡特兰数的生成函数。那么根据递归式，我们可以写出 $C(z) = z C(z)^2 + 1$ 以及 $C(0) = h_0 = 1$。

由 $C=zC^2+1$ 我们可以解出 $C(z) = \frac{1 \pm \sqrt{1-4z}}{2z}$。由于 $C(0) = 1$，分子上的符号取负。根据广义二项式定理，我们做以下推导：
$$
\begin{aligned}
h_n &= -\frac{1}{2}\cdot [z^{n+1}]\sqrt{1-4z} \\
&= -\frac{1}{2} \binom{\frac{1}{2}}{n+1} (-4)^{n+1} \\ 
&= -\frac{1}{2} \frac{\left(\frac{1}{2}\right)\left(\frac{1}{2}-1\right)\cdot \left(\frac{1}{2}-n\right)}{(n+1)!}\cdot 4^{n+1} \cdot (-1)^{n+1} \\
&= (-1)^n\cdot \frac{1}{2}\cdot 4^{n+1}\frac{(-1)\cdot(-3) \cdot (-5) \dots (1-2n)}{2^{n+1} \cdot (n+1)!} \\
&= \frac{1}{2} \cdot2^{n+1} \frac{(2n-1)\cdot (2n-3)\cdots 3\cdot1}{(n+1)!} \\
&= \frac{(2n)\cdot (2n-2)\cdots 2\cdot 1}{n!}\frac{(2n-1)\cdot (2n-3)\cdots 3\cdot1}{(n+1)!} \\
&= \frac{1}{n+1}\binom{2n}{n}.
\end{aligned}
$$
其中第 5 行到第 6 行的推导中，我们用到了 $2^n = \frac{2}{1}\frac{4}{2}\frac{6}{3}\cdots \frac{2n}{n}$.

*注*：有些文献里也会采用双阶乘记号，也即 $(2n)!! = (2n)(2n-2)\cdots 2$ 以及 $(2n-1)!!= (2n-1)(2n-3)\cdots 3\cdot 1$.



也可以用一种称为*微分法*的方法得到一个卡特兰数的递推公式。我们记 $1-2zC(z) = \sqrt{P(z)}$，其中 $P(z)$ 是一个度数为 $1$ 的多项式。那么对 $z$ 求导，就得到
$$
-2C(z) - 2z C'(z) = \frac{1}{2} \frac{P'(z)}{\sqrt{P(z)}} = \frac{1}{2} \frac{P'(z) \sqrt{P(z)}}{P(z)} = \frac{1}{2P(z)} P'(z)(1-2zC(z)).
$$
整理一下，就得到
$$
C(z)+zC'(z) - 2zC(z)-4z^2C'(z) = 1.
$$
两边作用 $[z^n]$，得出
$$
h_n = \frac{4n-2}{1+n}h_{n-1}.
$$
不难验证这个递推公式的正确性。

*注*：在之后的章节我们会讨论微分法的更多应用。

## 斯特林数

我们熟知一个度数为 $D$ 的多项式有三种经典表示：

1. 系数表示，也就是 $P(x) = \sum_{i=0}^D c_i x^i$。
2. 点值表示，也即给出 $P$ 在 $D+1$ 个不同的位置的取值 $(x_0, P(x_0)), \dots, (x_D, P(x_D))$.
3. 下降幂表示，也即定义 $x^{\underline{i}} = x(x-1)\dots (x-i+1)$，那么可以把 $P$ 写为 $P(x) = \sum_{i=0}^D b_i x^{\underline{i}}$.

由 (1) 和 (2) 相互转化可以使用多项式的多点求值和快速插值。

在点值表示中，如果我们的取值点是经典的前 $D+1$ 个非负整数，也即 $P(0),\dots,P(D)$，那么可以借助二项式反演，以 $O(D\log D)$ 的时间在 (2) 和 (3) 之间转化。

> 习题. 设计一个算法：给定一个 $D$ 次多项式 $P$ 的 $D+1$ 个取值 $P(0),P(1),\dots, P(D)$，在 $O(D\log D)$ 的时间内计算出形如 (3) 的表达。

以 (2) 作为桥梁，我们可以完成 (1) 和 (3) 之间的相互转化。我们也可以考虑如何直接由 $1$ 和 $3$ 相互转化，一种办法是借助斯特林数。

### 第一类斯特林数

我们考虑从 (3) 转化为 (1)。为此我们考虑对任意 $i\ge 0$，把 $x^{\underline{i}}$ 写成一个 $i$ 次多项式：
$$
x^{\underline{i}} = x (x-1)\dots (x-i+1) = \sum_{j=0}^i s(i,j)\cdot x^j,
$$
其中 $s(i,j)$ 是我们希望求出的系数。我们可以通过递推来求出 $s(i,j)$：
$$
s(i,j) = [x^j]x^{\underline{i}} = [x^j] (x^{\underline{i-1}}\cdot (x-(i-1))) = s(i-1,j-1) - (i-1)\cdot s(i-1,j),
$$
时间复杂度为 $O(n^2)$. 得到 $s(\star, \star)$ 之后，我们可以在 $O(n^2)$ 的时间内完成由 (1) 和 (3) 之间的相互转化。

这里的 $s(i,j)$ 就是（有符号）第一类斯特林数。

>定义 (有符号第一类斯特林数). 对任意 $i,j\ge 0$，定义 $s(i,j)$ 为 $x^{\underline{i}}$ 展开之后 $x^j$ 一项的系数。

类似地，我们可以考虑 $x^{\overline{i}}=x(x+1)\dots (x+i-1)$ 展开所得到的多项式 $x^{\overline{i}} = \sum_{j=0}^{i} s_u(i,j) x^j$，得到的系数 $s_u(i,j)$ 被称为（无符号）第一类斯特林数。

> 定义 (无符号第一类斯特林数). 对任意 $i,j\ge 0$，定义 $s_u(i,j)$ 为 $x^{\overline{i}}$ 展开后 $x_j$ 一项的系数。

无符号斯特林数满足递推：$s_u(i,j) = s_u(i-1, j-1) + (i-1)s_u(i-1, j)$.

有符号和无符号的斯特林数之间有如下关系：

> 定理. 对任意 $i,j\ge 0$，$s_u(i,j)\ge 0$, $s(i,j) = s_u(i,j) \cdot (-1)^{i-j}$.

**证明**：$s_u(i,j)\ge 0$ 非负可以通过归纳证明。对于第二个命题，我们对比：
$$
x^{\overline{i}} = \prod_{j=0}^{i-1} (x+j) = \sum_{j=0}^{i} s_u(i,j) x^j, \\
x^{\underline{i}} = \prod_{j=0}^{i-1} (x - j) = \sum_{j=0}^i s(i,j) x^j.\\
$$
我们可以暴力展开中间的乘积项，因为每个括号里可以选择 $x$ 项或者常数项，总共会有 $2^i$ 个项。考虑其中一个特定的项，如果有 $k$ 个括号选择了常数项，那么这一项会贡献到 $x^{i-k}$ 上。而我们对比上下两式，若 $k$ 个括号选择常数项，那么这样一个项在上下两个式子里的贡献的符号相差 $(-1)^k$，这个符号差只和 $k$ 有关。因此，对于任意的奇数 $k$，所有贡献到 $x^{i-k}$ 的项在上下两式中产生相反的贡献；而对于所有偶数 $k$，贡献到 $x^{i-k}$ 的项在上下两式产生相同的贡献，因此我们得出 $s(i,j) = s_u(i,j)(-1)^{i-j}$.

#### 第一类斯特林数的组合意义

对于无符号第一类斯特林数 $s_u(i,j)$，它有一个这样的组合理解：$s_u(i,j)$ 表示把 $i$ 个元素划分成 $j$ 个非空的圆排列的方案数（这是说，把 $i$ 个元素分成非空的 $j$ 组，并分别把每组的元素的排成一个圆牌列）。

我们可以通过它的递推公式看出这一点。回忆递推公式
$$
s_u(i,j) = s_u(i-1, j-1) + (i-1) s_u(i-1, j).
$$
这是说，我们考虑第 $i$ 个元素，它可以单独构成一组（方案数为 $s_u(i-1, j-1)$），也可以加入已经存在的某一组。因为插入每一组的开头和结尾实质上是同一种方案（因为我们这里只考虑圆牌列），所以总共有 $i-1$ 种方法来完成插入。综合两种情况得到这个递推公式。

#### 第一类斯特林数的计算

##### 递推

按照递推式，可以在 $O(N^2)$ 时间内计算出 $s_u(\le N,\le N)$。

##### 一行中的斯特林数

固定 $N\le 10^5$，计算 $s_u(N,\star)$。这相当于求 $x^{\overline{N}}$ 的系数表达. 我们使用倍增，假设已经计算出 $x^{\overline{N}}$ 的系数表达，那么
$$
x^{\overline{2N}} = x^{\overline{N}} \cdot (x+N)^{\overline{N}}.
$$
记 $x^{\overline{N}} = \sum_{i=0}^N b_i x^i$，我们注意到
$$
[x^i](x+N)^{\overline{N}} = [x^i]\sum_{j=0}^{N} b_j (x+N)^j = \sum_{j=i}^N \binom{j}{i} b_j  N^{j-i}.
$$
由序列$(b_j\cdot j!)_{j=0}^N$ 和 $(N^{j-i}/(j-i)!)_{j-i=0}^N$ 做（减法）卷积可以得到序列 $([x^i](x+N)^{\overline{N}})_{i=0}^{N}$，时间复杂度为 $O(N\log N)$。得到 $(x+N)^{\overline{N}}$ 后可以通过一次 FFT 计算出 $x^{\overline{2N}}$，时间复杂度为 $O(N\log N)$。综上，我们可以通过倍增 + FFT在 $O(N\log N)$ 的时间内计算出 $s_u(N,\star)$.

##### 一列中的斯特林数

固定 $D\le 10^5$，对任意的 $N\le 2\times 10^5$ 计算 $s_u(N,D)$。此时我们应该考虑第一类斯特林数的组合意义：把 $N$ 个元素划分成 $D$ 个圆牌列的方案数。我们定义
$$
F(x) = \sum_{i=1}^{\infty}\frac{(i-1)!}{i!}x^i = \sum_{i=1}^{\infty} \frac{f_i}{i!} x^i.
$$
这里 $f_i$ 为把 $i$ 个元素排成一个圆牌列的方案数，而 $F(x)$ 为 $(f_i)_{i\ge 1}$ 的指数型生成函数。注意到 $F(x)^2$ 即为把 $i$ 个元素划分成两个圆牌列的方案数，依次类推 $F(x)^D$ 即为把 $i$ 个元素划分成 $D$ 个圆牌列的方案数。使用生成函数的 ln / exp 或者倍增来计算生成函数的 $D$ 次幂。

*注.* 不难发现 $F(x) =\sum_{i\ge 1} x^i/i =  -\ln(1-x)$.

### 第二类斯特林数

我们考虑从多项式的表示 (1) 转化为 (3)，为此我们需要使用第二类斯特林数。在此之前，我们先通过组合意义来引入第二类斯特林数。

> 定义 (第二类斯特林数). 对任意 $n,m\ge 0$，第二类斯特林数 $S(n, m)$ 定义为把 $n$ 个不同的元素划分成 $m$ 个非空集合的方案数。

我们注意到第二类斯特林数满足递推：
$$
S(n,m) = S(n - 1, m) + m \cdot S(n - 1, m).
$$
这个递推可以通过组合意义来解释。我们考虑第 $n$ 个元素，如果它单独作为一个集合，那我们还需把其他元素划分成 $m-1$ 个非空集合；我们也可以把前 $n-1$ 个元素划分成 $m$ 个非空集合，然后把第 $n$ 个元素插入到某个集合中。枚举两种情况并求和就得到了上述递推。

现在回到多项式表示的转化问题上。为了从系数表示转化为下降幂表示，我们首先把 $x^i$ 写成 $x^{\underline{j}}, j\le i$ 的线性表示。我们有
$$
x^i = \sum_{j=0}^i S(i, j) x^{\underline{j}}.
$$
这个式子同样有一个组合解释：$x^i$ 表示将 $i$ 个可以区分的小球扔进 $x$ 个框的方案数。为了计算这个方案数，我们可以枚举有 $j\le i$ 个框非空，先把 $i$ 个小球分成非空的 $j$ 组，接着从 $x$ 个框里按顺序挑出 $j$ 个框来依次装这 $j$ 组小球。这样我们就有 $S(i, j)\cdot x^{\underline{j}}$ 种方案来把 $i$ 个小球扔进 $j$ 个框，对 $j$ 求和得到上述等式。对于所有的非负整数，我们都可以用此论证证明等式。注意到等式两边都是度数为 $i$ 的多项式，由于他们在无穷多个点上取值相同，它们只能是同一个多项式，因此上式对于一般的 $x\in \mathbb{R}$ 都成立。

对于一个正整数 $x\in \mathbb{N}$，我们把 $-x$ 代入上式可得 $(-x)^i = \sum_{j=0}^i S(i,j) (-x)^{\underline{j}}$。注意到 $(-x)^{\underline{j}}=(-1)^j\cdot x^{\overline{j}}$，化简就可以得到
$$
x^i = \sum_{k=0}^i (-1)^{i-j} \cdot S(i,j)\cdot  x^{\overline{i}},
$$
这个式子给出了用上升幂表示通常幂的公式。

#### 第二类斯特林数的容斥公式

我们来考虑斯特林数的计算问题。使用递推公式计算一个斯特林数 $S(n, m)$ 需要 $O(nm)$ 的计算量。依下述定理，我们可以在 $O(m)$ 的时间内计算一个特定的斯特林数 $S(n, m)$。

> 定理. 对任意 $n,m\ge 0$，以下公式成立.
> $$
> S(n,m) = \frac{1}{m!} \sum_{k=0}^m (-1)^k \binom{m}{k} (m - k)^n.
> $$

这个公式可以用容斥原理证明。回忆 $S(n,m)$ 表示把 $n$ 个元素划分成 $m$ 个非空组的方案数。因此 $S(n,m)\cdot m!$ 为把 $n$ 个不同的小球扔进 $m$ 个可以区分的框并要求每个框非空的方案数。忽略非空的要求，我们有 $m^n$ 种方法来把小球扔进框，为了减掉不合法的方案，我们使用容斥原理枚举至少有某 $k$ 个盒子为空的情形，计算对应的方案数并配上容斥系数即可。

进一步地，固定 $n\ge 1$，我们发现
$$
S(n, m) = \sum_{k=0}^m \frac{(-1)^{k}}{k!} \cdot \frac{(m-k)^n}{(m-k)!}
$$
是一个卷积的形式。因此可以在 $O(m\log m)$ 的时间内求出第 $n$ 行的前 $m$ 个斯特林数。

#### 第二类斯特林数的生成函数

全体非空集合的生成函数为 $e^z -1$，给定 $m\ge 1$, $\frac{(e^z-1)^m}{m!}$ 就给出了把 $n$ 个元素划分 $m$ 个非空集合的方案数。注意到这恰好是 $S(n, m)$ 的指数生成函数，即
$$
\sum_{n\ge 0} \frac{S(n,m)}{n!} z^n = \frac{(e^z - 1)^m}{m!}.
$$
固定 $m$，使用分治FFT（或者多项式求 exp）可以在 $O(n\log(nm))$ 的时间内计算出一列斯特林数 $(S(i,m))_{i=0}^n$.

*注.* 我们也注意到通过生成函数可以给前述容斥公式一个新的证明：
$$
\begin{aligned}
\frac{S(n, m)}{n!} &= [z^n]\frac{(e^z-1)^m}{m!} \\
&= [z^n]\frac{1}{m!}\sum_{i=0}^m \binom{m}{i} (-1)^{n-i} e^{iz}\\
&= \frac{1}{n!}\cdot \frac{1}{m!}\sum_{i=0}^m \binom{m}{i} i^n (-1)^{n-i}.
\end{aligned}
$$

### 两类斯特林数的反演公式

我们回忆通常幂和下降幂之间的转化公式：
$$
\begin{aligned}
x^{i} &= \sum_{j=0}^i S(i, j)\cdot  x^{\underline{j}} \\
x^{\underline{i}} &= \sum_{j=0}^i s(i, j)\cdot x^j
\end{aligned}
$$


我们把第二行代入第一行，得到
$$
\begin{aligned}
x^i &= \sum_{j=0}^i S(i, j) \sum_{k=0}^i s(j, k) \cdot x^k\\
&=\sum_{k=0}^j x^k \sum_{j=k}^i S(i, j)\cdot s(j, k).
\end{aligned}
$$
由于等式两边表示同一个多项式，我们就得到了斯特林反演公式。
$$
\sum_{j=k}^i S(i, j) \cdot s(j, k) = [i = k].
$$
我们也可以把第一行代入第二行得到一个对称的结论。综合两个推导，我们得到以下斯特林反演公式。

> 定理 (斯特林数反演). 令 $s(\cdot,\cdot),S(\cdot, \cdot)$ 分别表示（有符号）第一类斯特林数和第二类斯特林数，对任意 $0\le k\le i$，我们有
> $$
> \begin{aligned}
> \sum_{j=k}^i S(i, j) \cdot s(j, k) &= [i = k] \\
> \sum_{j=k}^i s(i, j) \cdot S(j, k) &= [i = k].
> \end{aligned}
> $$

**应用.** 假设 $(f_i)$ 和 $(g_i)$ 是两个数列，如果
$$
f_i = \sum_{j\le i} S(i,j)\cdot g_j.
$$
那么
$$
g_i =\sum_{j\le i} s(i, j)\cdot f_j.
$$

**连通图的计数.** 作为一种特殊情形，我们考虑第一个公式在 $k=1$ 时的情形。由于 $s(j,1)=(j-1)! \cdot (-1)^{j-1}$，我们得到
$$
\sum_{j=1}^i S(i, j)\cdot (j-1)! \cdot (-1)^{j-1} = [i = 1].
$$
由于这个公式频繁出现在一类关于等价类计数的问题，因而有必要对其特别注意和练习。我们可以用图连通性的语言来描述这一类问题：考虑一族 $n$ 个点的带标号无向图 $\mathcal{G} = \{G:G = ([n],E)\}$ (例如，$\mathcal{G}$ 包含所有 $\frac{n^2}{10}$ 条边的简单无向图），而我们想计算 $\mathcal{G}$ 中有多少个图是连通的。对此类问题，一种基于斯特林反演（容斥）做计数的思路是这样的：我们令 $c(G)$ 表示图 $G$ 的连通块个数，那么就有
$$
ANS = \sum_{G\in \mathcal{G}} [c(G) = 1] = \sum_{G\in \mathcal{G}} \sum_{j=0}^n S(c(G), j) \cdot (j-1)! \cdot (-1)^{j-1}.
$$
在一些问题里，我们可以通过组合意义来理解和实现等式右边的式子，从而做高效计数。在斯特林数的专题训练中，我们会以具体的例子来阐述上述公式的应用。

## 伯努利数

*问题引入.* 给定 $n$, $k$，我们想计算
$$
S(n,k)= \sum_{i=0}^{n-1} i^k.
$$
进一步地，我们已经知道 $S(n,k)$ 是一个关于 $n$ 的 $k+1$ 次多项式，现在我们想求出它的系数。

**推导.** 对 $i^k$ 的求和比较困难，但是另一方面，我们回忆对等比数列做求和非常容易。注意到形式幂级数 $e^{iz}$ 中 $z^k$ 一项的系数恰好是 $\frac{i^k}{k!}$，这启发我们做变换：
$$
S(n,k) = \sum_{i=0}^{n-1} [z^k/k!] e^{iz} = [z^k/k!] \frac{e^{nz}-1}{e^z-1}.
$$
其中 $[z^k/k!] P(z)$ 是一个作用在形式幂级数上的算符。它的定义为：假设 $P(z) = \sum_{j} \frac{c_j}{j!} z^j$，那么 $[z^k/k!] P(z) = c_k$. 此时，我们将 $\frac{1-e^{nz}}{1-e^z}$ 看成一个关于 $z$ 的形式幂级数，做一个多项式求逆之后可以得到它的第 $k$ 项的系数，这样就能在 $\Theta(k\log k)$ 的时间内得出上述问题的答案了。



更进一步，我们来仔细研究一下 $\frac{e^{nz}-1}{e^z-1}$ 这个式子。它的分子是
$$
e^{nz} - 1= \sum_{i=1}^{\infty} \frac{n^i}{i!}\cdot z^i,
$$
而分母是
$$
e^z-1 = \sum_{i=1}^{\infty} \frac{z^i}{i!}.
$$
注意到分母的常数项为 0，它本身并没有逆元。为了能够求逆，我们在分子添上一个 $z$，考虑 $\frac{z}{e^z-1}$。我们假设求出了它的逆元如下：
$$
\frac{z}{e^z-1} = \sum_{i=0}^{\infty} \frac{B_i}{i!}\cdot z^i.
$$
那么我们就有
$$
[z^k/k!]\frac{e^{nz}-1}{e^z-1}=[z^k/k!] \left(\frac{e^{nz}-1}{z}\cdot \frac{z}{e^z-1} \right) =  k!\cdot \sum_{i+j=k} \frac{n^{i+1}\cdot B_j}{(i+1)! j!}.
$$
我们发现，等式的右边是一个关于 $n$ 的 $k+1$ 次多项式，这正是我们想得到的东西。

在以上推导里扮演了重要作用的数列 $(B_i)$ 即为伯努利数。

> 定义（伯努利数）. 我们通过生成函数定义（有符号）伯努利数如下。定义伯努利数 $(B_i)_{i=0}^{\infty}$ 为一数列，满足下述等式:
> $$
> \frac{z}{e^z-1} = \sum_{i=0}^\infty \frac{B_i}{i!}\cdot z^i.
> $$
> 不难发现这样的数列存在且唯一。

*注*：人们也定义了无符号伯努利数 $B_i^+$ 为生成函数 $\frac{z}{1-e^{-z}}$ 的系数，我们发现 $B_i^+=|B_i|$。

同时，根据上面的推导，我们发现伯努利数可以用来给出关于 $n$ 的 $k$ 次多项式 $S(n,k)=\sum_{i=0}^{n-1} i^k$ 的系数：

> 定理. 我们有下式成立：
> $$
> S(n,k):= \sum_{i=0}^{n-1} i^k = \frac{1}{k+1}\cdot \sum_{j=0}^{k}\binom{k+1}{j}\cdot B_j \cdot n^{k+1-j}.
> $$

伯努利数也可以用以下方法递归定义：
$$
B_m = [m=0] - \sum_{k=0}^{m-1}\binom{m}{k}\frac{B_k}{m-k+1}.
$$
证明也很简单，考虑等式 $\left( \sum_{i=0}^{\infty} \frac{B_i}{i!} z^i \right)\left( \frac{e^z-1}{z} \right) = 1$，对两边作用算子 $[z^m/m!]$ （也即考虑 $m$ 次项系数）即可。

## 一种线性求和黑魔法

Credit: [Entropy Increaser](https://blog.csdn.net/EI_Captain/article/details/115118001).

接下来我们介绍一种由 Entropy Increaser (Baitian Li) 等人发明的一种针对多项式和形式幂级数的线性求和算法。这个算法推导简单，并且它统一了很多关于多项式的求和的问题中 ad hoc 的推导，是一个值得一学的新技术。

> 算法. 设 $F(x)$ 是一个微分有限 (D-Finite) 的函数。令 $G(x)$ 为一个生成函数，$(a_i)$ 为一个未知数列。设对每个 $0\le k\le n$ 给定了
> $$
> s_k = \sum_{j=0}^n a_j[x^j]G(x)^k,
> $$
> 那么存在一个线性($O(n)$)时间的算法计算
> $$
> \sum_{j=0}^{n} a_j [x^j]F(G(x)).
> $$

*注.* 所谓微分有限，是指 $F$ 满足一个微分方程：
$$
\sum_{i=0}^{t} p_i(z) F^{(i)}(z) = 0,
$$
其中 $p_i(z)$ 为一系列多项式，$t$ 是一个有限的常数。

在很多的应用中，我们会取 $G(x) = \exp(x)$，此时 $[x^j]\exp(kx) =\frac{k^j}{j!}$. 在此情形下，上述算法自然对应了一类多项式求和问题。

> 推论. 假设 $F(z) = \sum_{i\ge 0} f_i z^i$ 微分有限。令 $P(x)=\sum_{i=0}^D c_i\cdot x^i$ 为一个 $D$ 次多项式。给定 $P(0),P(1),\dots,P(D)$，存在一个算法在 $O(D)$ 时间内计算
> $$
> \sum_{j=0}^D c_j \left( \sum_{i=0}^{\infty} f_i \cdot i^j\right) =\sum_{i=0}^{\infty} f_i\sum_{j=0}^D c_j \cdot i^j = \sum_{i=0}^{\infty} f_i \cdot P(i).
> $$

(如果觉得这个推论不好理解，请参考下面 [例1. 插值] 中的内容。)

### 例子

在叙述算法之前，我们先代入几个例子看看这个算法的通用性。

##### 例1. 插值

>  问题. 假设 $P(x)$ 是一个度数为 $D$ 的多项式，已经给出 $P(0),P(1),\dots, P(D)$，我们想在 $O(D)$ 的时间内计算出 $P(n)$。

设 $P(x)=\sum_{j=0}^D \frac{a_j}{j!} x^j $ 。我们取 $G(x)$ 为 $\exp(x)$，那么对于任意 $k\in [0,D]$，我们有
$$
\sum_{j=0}^D a_j[x^j]G(x)^k = \sum_{j=0}^{D} a_j [x^j]\exp(kx) = \sum_{j=0}^D \frac{a_j}{j!} k^j = P(k).
$$

因此套用算法所需要的输入已经齐全。我们构造 $F(G)=G^n$​，$F$ 是一个微分有限的函数，它满足微分方程 $z\cdot F'(z) - n\cdot F(z) = 0$. 最后注意到
$$
\sum_{j=0}^D a_j[x^j] F(G(x)) = \sum_{j=0}^D a_j[x^j]\exp(nx) = \sum_{j=0}^D \frac{a^j}{j!} n^j = P(n),
$$
这正是我们想要的答案。

##### 例2. （清华集训）如何优雅地求和

> 问题. 给定一个 $D$ 次多项式 $f$ 在 $f(0),\dots, f(D)$ 处的取值，再输入 $n\le 10^9$ 和 $\alpha\in (0, 1)$，计算
> $$
> Q(f,n,\alpha) = \sum_{k=0}^n f(k) \binom{n}{k} \alpha^k(1-\alpha)^{n-k}.
> $$

我们依然令 $f$ 的系数为 $(a_i/i!)$，取 $G(x) = \exp(x)$，那么对任意 $k\in [0,D]$，
$$
\sum_{j=0}^D a_j[x^j] G(x)^k = \sum_{j=0}^D \frac{a_j}{j!} k^j = f(k).
$$
我们构造 $F$ 为 $F(z) = \sum_{k=0}^n \binom{n}{k} (\alpha z)^k (1-\alpha)^{n-k} = (\alpha z + 1-\alpha)^n$，那么
$$
\begin{aligned}
\sum_{j=0}^D a_j[x^j] F(G(x)) 
&= \sum_{j=0}^D a_j[x^j] \left( \sum_{k=0}^n (\alpha G(x))^k (1-\alpha)^{n-k}\binom{n}{k} \right) \\
&= \sum_{j=0}^D \frac{a_j}{j!} \sum_{k=0}^n \alpha^k k^j(1-\alpha)^{n-k}\binom{n}{k} \\
&= \sum_{k=0}^n\binom{n}{k} \alpha^k (1-\alpha)^{n-k}\sum_{j=0}^D \frac{a_j}{j!}\cdot  k^j \\
&= \sum_{k=0}^n\binom{n}{k}\alpha^k(1-\alpha)^{n-k} f(k) \\
&= Q(f,n,\alpha).
\end{aligned}
$$
不难验证 $F$ 是一个微分有限的幂级数，它满足微分方程 $(\alpha z + 1 - \alpha) F' - n F = 0$。因此，套用上述算法可以在 $O(D)$ 的时间内解决此问题，比传统解法的 $O(D\log D)$ 更加优越。

之后我们会介绍更多的例子，下面我们来叙述算法。

### 算法

首先，我们把所求答案记为 $ANS$，也就是
$$
ANS := \sum_{j=0}^{n} a_j [x^j]F(G(x)).
$$
我们首先来研究 $F(G(x))$。设 $F(z) =\sum_{i\ge 0}f_i z^i$，那么我们可以自然地把 $F(G(x))$ 写为
$$
F(G(x)) = \sum_{i = 0}^{\infty} f_i \cdot G(x)^i.
$$
这样的展开并不利于我们做计算，因为对于任意大的 $i$，都可能有 $[x^j]G(x)^i \ne 0$。比较好的做法是，设 $G(0) = c$，我们考虑把 $F$ 写为 $F(z) = \sum_{i\ge  0} \tilde{f}_i \cdot  (z-c)^i$（也就是说，在常数 $c$ 处展开 $F$），那么我们就得到了
$$
F(G(x)) = \sum_{i=0}^{\infty} \tilde{f}_i \cdot (G(x)-c)^i.
$$
这里我们注意到，当 $i > j$ 时，一定有 $x^{j+1}|(G(x)-c)^i$，从而 $[x^j]G(x)^i = 0$。由于我们只关心 $[x^{\le n}]F(G(x))$，对于上式，我们只需要展开到第 $n$ 层即可。于是，我们考虑定义 $\hat{F}$ 为 $F$ 的一个截断：
$$
\hat{F}(z) = \sum_{i=0}^n \tilde{f}_i \cdot (z-c)^i = F(z) \bmod (z-c)^{n+1}.
$$
那么我们有
$$
\begin{aligned}
ANS &= \left(\sum_{j=0}^n a_j[x^j] \right) F(G(x)) \\
&= \left(\sum_{j=0}^n a_j[x^j] \right) \left( \sum_{i=0}^\infty \tilde{f}_i \cdot (G(x) - c)^i \right) \\
&= \left(\sum_{j=0}^n a_j[x^j] \right) \left( \sum_{i=0}^{\color{red}{n}} \tilde{f}_i \cdot (G(x) - c)^i \right) \\
&= \left( \sum_{j=0}^n a_j[x^j] \right) \hat{F}(G(x)).
\end{aligned}
$$
现在注意到 $\hat{F}(z)$ 是一个度数不超过 $n$ 的多项式，我们知道它在 $c$ 处的展开式为 $\hat{F}(z) = \sum_{i=0}^n \tilde{f}_i\cdot (z-c)^i$。假设它在 $0$ 处的展开式为
$$
\hat{F}(z) = \sum_{i=0}^n \hat{f}_i z^i.
$$
假设我们能算出 $(\hat{f}_i)_{i=0}^n$，我们可以依以下方法在 $O(n)$ 时间内计算出答案：
$$
\begin{aligned}
ANS 
&= \left( \sum_{j=0}^n a_j[x^j]\right) \left( \sum_{i=0}^n \hat{f}_i \cdot G(x)^i \right) \\
&= \sum_{i=0}^n \hat{f}_i \left( \sum_{j=0}^n a_j [x^j] G(x)^i \right) \\
&= \sum_{i=0}^n \hat{f}_i \cdot s_i.
\end{aligned}
$$
于是，我们最后需要解决的问题是：如何在 $O(n)$ 的时间内计算出 $(\hat{f}_i)_{i=0}^n$？

我们需要利用微分方程。设 $F(z)$ 满足的 $t$ 阶微分方程为
$$
\sum_{i=0}^t P_i(z)\cdot  F^{(i)}(z) = 0.
$$
*注.* 在大多数应用中，我们有 $t=1$，并且多项式 $P_i(z)$ 的度数不超过 $1$。简单起见，在思考之后的推导时不妨先带入 $t=1$。

由于平移不变性，我们也有
$$
\sum_{j=0}^t P_j(z + c) \cdot F^{(j)}(z+c) = 0.
$$
注意到 $F(z+c) = \sum_{i\ge 0} f_i\cdot (z+c)^i = \sum_{i\ge 0} \tilde{f}_i\cdot z^i$，而上式给出了一个关于 $\tilde{f}_i$ 的 $O(t)$ 阶递推关系，不妨设为 $\tilde{f}_i = \sum_{j=1}^{O(t)} \tilde{f}_{i-j} \cdot c_j(i)$.

回忆 $\hat{F}(z+c)=\sum_{i=0}^{\color{red} n} \tilde{f}_i \cdot z^i$ 是 $F(z+c)$ 的一个截断，对于 $\hat{F}(z+c)$ 的系数 $(\tilde{f}_0,\tilde{f}_1,\dots, \tilde{f}_{n}, 0, 0,\dots)$ 来说，递推关系 $\tilde{f}_i =\sum_{j=1}^{O(t)} \tilde{f}_{i-j}\cdot c_j(i)$ 在 $i\le n$ 的时候依然成立，在 $i-n\gg t$ 的时候由于递推的齐次性也成立，因此我们只需要在 $|i-n|\lesssim t$ 的位置加一个扰动项即可。形式化地说，考虑如下幂级数
$$
D(z):= \sum_{j=0}^t P_j(z+c)\cdot \left( F^{(j)}(z+c) -\hat{F}^{(j)}(z+c) \right) = \sum_{j=0}^t P_j(z+c) \left(\sum_{i=n+1}^\infty \tilde{f}_i z^i\right)^{(j)}.
$$
当 $i- n \gg t$ 时，$[z^i]D(z) = 0$，当 $n-i \gg t$ 时，同样也有 $[z^i]D(z) = 0$。因此 $D$ 是一个只包含 $O(t)$ 个非零项的稀疏多项式。于是我们有
$$
\sum_{j=0}^t P_j(z+c)\hat{F}^{(j)}(z+c) = -D(z)，
$$
将其平移回去，得到
$$
\sum_{j=0}^t P_j(z) \hat{F}^{(j)}(z)= -D(z-c).
$$
这个式子蕴含了一个关于 $\hat{f}_i$ 的递推关系，依此式进行递推即可。

#### 总结

1. 要计算 $ANS := \sum_{j=0}^{n} a_j [x^j]F(G(x))$，如果依定义展开 $F(G(x))=\sum_{i\ge 0} f_i \cdot G(x)^i$，那么任意大的 $G(x)^i$ 项对答案都会有贡献，无法快速计算。因此我们在 $G(0)=c$ 处展开得到 $\sum_{j=0}^n a_j[x^j] \sum_{i=0}^{\infty} \tilde{f}_i (G(x)-c)^i$.
2. 此时我们可以做截断 $\sum_{j=0}^n a_j[x^j] \sum_{i=0}^{\color{red}n} \tilde{f}_i (G(x)-c)^i$，令 $\hat{F}=\sum_{i=0}^n \hat{f}_i z^i$ 为截断后的多项式。我们发现 $ANS = \sum_{i=0}^n \hat{f}_i s_i$，于是只需要计算 $(\hat{f}_i)_{i=0}^n$。
3. 最后我们计算 $\hat{f}_i$ . 考虑它是怎样得来的：将 $F(z)$ 平移到 $F(z+c)$，截断取前 $n$ 项得到 $\hat{F}(z+c)$，再平移得到 $\hat{F}(z)$. 由 $F$ 的微分方程得到 $F(z+c)$ 的系数 $(\tilde{f}_i)$ 满足一个齐次递推，这个齐次递推蕴含了关于 $(\tilde{f}_0,\dots, \tilde{f}_n, 0, \dots)$ 的一个非齐次递推，把这个非齐次递推平移得到关于 $\hat{f}_i$ 的递推即可。

### 更多例子

> TJOI 2016 求和. 给定 $n\le 2\times 10^5$，计算 $f(n) = \sum_{i=0}^n \sum_{j=0}^i S(i,j)\cdot 2^i\cdot j!$，其中 $S(i,j)$ 表示第二类斯特林数。

考虑此式的一个组合意义：准备 $i\le n$ 个元素，划分成带标号的 $j\le i$ 组，并对每一组黑白染色的方案数。

令 $G(x)=e^x$, $G'(x)=G(x)-1$, 那么划分成有顺序的 $j$ 组，并对每一组染色的指数生成函数为 $(2G'(x))^j$，对 $j$ 求和得到划分成若干组的生成函数为
$$
\frac{1}{1-2G'} = \frac{1}{3-2G}.
$$
于是定义 $F(z)=\frac{1}{3-2z}$。我们要对 $i\in \{0,1,\dots, n\}$ 求和，这也就是
$$
\sum_{j=0}^{n}j!\cdot [x^j] F(G(x)).
$$
要套用上述算法，我们需要能计算
$$
s_k = \sum_{j=0}^n j![x^j] \exp(kx) = \sum_{j=0}^n k^j,
$$
这只是一个简单的等比数列求和。

> 国王奇遇记加强版之再加强版. 给定 $n\le  10^9, q\le  10^6$，计算 $\sum_{i=0}^n q^i i^q$。

我们使用推论。构造多项式 $P(x) = x^q$。构造辅助函数 $F(z) = \sum_{i=0}^n q^i z^i= \frac{1-(zq)^{n+1}}{1-zq}$，可以验证 $F$ 满足某个 $1$ 阶微分方程。我们要计算的是 $\sum_{i=0}^{n} f_i P(i)$.

可以在 $O(q)$ 的时间内计算出 $P(0),\dots, P(q)$，套用算法即可。

### 一些常见生成函数的微分方程

来源：杜老师的博客。
$$
\begin{aligned}
g_1(x) = \sum_{i\ge 0} \frac{x^i}{i!} &\Rightarrow g_1 = g_1'\\
g_2(x) = \sum_{i=0}^k \frac{x^i}{i!} &\Rightarrow g_2 = g_2' + \frac{x^i}{i!} \\
g_3(x) = \sum_{i\ge 0} x^i i! &\Rightarrow g_3 = g_3'x^2 + g_3x + 1 \\
g_4(x)=  \sum_{i\ge 0} \frac{x^i}{i!(i+k)!} &\Rightarrow g_4 = g_4''x + (k+1) g_4' \\
g_5(x) = \sum_{n\ge 0} \frac{1}{(k-1)n+1}\binom{kn}{n} x^{(k-1)n + 1} &\Rightarrow g_5 = \frac{kxg_5'}{1 + (k-1)g_5'}\\
g_6(x) = (1+x)^a(1-x)^b &\Rightarrow g_6'=\frac{ag_6}{1+x} +\frac{bg_6}{1-x} \\
g_7(x) = \sum_{i=0}^k \binom{n}{i}a^ib^{n-i} &\Rightarrow ng_7(a'+b')-g_7(a+b)=n\binom{n-1}{k}(a'a^kb^{n-k}-b'a^{k+1} b^{n-k-1}) \\
g_8(x) = g^n &\Rightarrow ng_8 f'=fg_8'
\end{aligned}
$$
注意这里我们讨论的是形式导数和形式幂级数，一般来说它们不能以微积分意义上的级数理解（举例来说，我们注意到 $g_3(x)$ 在 $x\ne 0$ 时甚至不收敛）。

> 习题：构造 $F(z) = \frac{1}{3-2z}$ 所满足的微分方程。

## 拓展阅读

1. [关于整数拆分和五边形数定理的一个博文](https://blog.csdn.net/qq_33229466/article/details/80359560)
2. [快速求和：Entropy Increaser 的讲稿](https://blog.csdn.net/EI_Captain/article/details/115118001)
3. [微分法：杜老师的讲稿](https://codeforces.com/blog/entry/76447)
4. [计算斯特林数的一些快速算法 (Entropy Increaser)](https://blog.csdn.net/EI_Captain/article/details/108886423)
